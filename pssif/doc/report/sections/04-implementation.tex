\chapter{Implementation}
\label{chap:impl}

In the last chapter the conceptual approach to the realisation of the PSS-IF Proof-of-Concept was described. In particular, the latter sections of \chapref{chap:approach} describe the principles behind the chosen transformation method. In this context, this chapter focuses on the implementation of the framework. The chapter is structured as follows: \secref{sec:impl:technology} describes the technology stack used for the implementation. In the consequent \secref{sec:impl:principles} the adopted software development guiding principles are presented. Thereafter, \secref{sec:impl:structure} provides an overview of the project structure. \secref{sec:impl:components} follows with a description of each component of the PSS-IF PoC and, finally, \secref{sec:impl:process} describes the import and export processes and the collaboration of all components of the framework.

\section{Technology Stack}
\label{sec:impl:technology}

This section defines the technologies used for the implementation of the PSS-IF Proof-of-Concept. Each of the following subsections addresses a particular aspect of the technological stack. Note that all the software and tools used for the realization of the PoC are widely accepted industry standards.

\subsection{Programming Language}

To enable an easier and more rapid development of the prototype, a high-level programming language can better be utilized. Due to previous experience and know-how, the authors have chosen the Java Programming Language. Furthermore, the code is compliant with Java version 7, as distributed by Oracle. 

\subsection{Revision Control}

For improved parallelisation, better code maintenance and easier documentation, a distributed revision control can be used. While there are numerous alternatives, the authors have chosen GIT as a modern and powerful solution.

\subsection{Build Process and Dependency Management}

For the automated build process, as well as for the management of dependencies to external libraries, Apache Maven has been used.

\subsection{Test Framework}

For the execution of automated tests, JUnit, an industry standard framework, has been used.

\subsection{Used Libraries}

Next to the libraries provided by Oracle's Standard Java Runtime Environment, the following additional libraries have been used:

\paragraph{apache-compress} An API for the manipulation of different kinds of compressed files. In the scope of the Proof-of-Concept, the API is used in the Visio VSDX processing component, for the zipping and unzipping of VSDX files.

\paragraph{guava} Google Guava is a set of common libraries, mainly developed by Google. The package includes useful APIs for the manipulation of collections, the usage of function and predicates, and others.

\paragraph{emf} The Eclipse Modelling Framework (EMF) library is used for the serialization and de-serialization of eCore and XML Metadata Interchange (XMI) files, enabling the processing of SysML4Mechatronics data.

\paragraph{junit} JUnit is an industry standard unit-testing framework.

\section{Guiding Principles}
\label{sec:impl:principles}

During the design and implementation of the PSS-IF PoC the authors have followed the principles and best-practices for software development. Some of the guiding principles were the following:

\paragraph{Standardization:} Usage of widely used and accepted industry-standard tools, technologies and formats, to render the produced solution more accessible to new developers and compliant to other pieces of software.

\paragraph{Patterns:} To maximize code quality and understandability, common architecture and design patterns have been utilized.

\paragraph{Object-Orientation:} The code is developed in accordance with the paradigms of the Java programming language -- it is mostly object-oriented and imperative.

\paragraph{Separation of Concerns:} The implementation follows the separation of concerns paradigm.

\section{Project Structure}
\label{sec:impl:structure}

The PSS-IF PoC is developed as an Apache Maven project, further divided into a root project, called ''\textbf{pssif}'' and a number of sub-modules. The root project is used for the provision of common development and  build configuration, as for example the specification of common dependencies with a fixed version over all modules. This avoids redundancy and improves the manageability of the developed code. Each of the modules represents a component of the PSS-IF PoC architecture on a coarse level of abstraction. Note that while it is possible to establish a project with fine-grained Maven modularity, division in fine-grained modules would make it more difficult to capture the project structure. This is why the authors have tried to find a balance between capturing coarse-level architectural concepts through Maven modularization, while fine-grained modularization of components is achieved through the packaging mechanism of the Java programming language.

This section covers the coarse-grained separation realized through Maven modularization, while \secref{sec:impl:components} is concerned with the fine-grained architectural modularization of the project. Currently, the PSS-IF PoC consists of four modules, as depicted in \color{red} TODO figref\color{black}.

\color{red} TODO screenshot of project strucutre\color{black}

\paragraph{Core} The ''\textbf{core}'' Maven module contains the fundamental Application Programming Interface (API) of the framework. This API defines the concepts through which the PSS-IF Domain-Specific Language (DSL) is described, such as Metamodel, Model, NodeTypes, Nodes etc. Furthermore, the core module provides an implementation layer for the concepts of the PSS-IF DSL, as well as a number of common utilities, like for example a generator for the canonic PSS-IF Metamodel, as depicted in \chapref{chap:intro}.

\paragraph{Transform} The ''\textbf{transformation}'' Maven module provides the Application Programming Interface (API) used for the definition and execution of transformations, as well as for input and output (I/O) operations. Next to the APIs, this module also contains their implementation, as well as a number of commonly used helping utilities, concerned with transformation or the serialization to or de-serialization from external formats. Finally, this module contains implementations for the supported source and target languages.

\paragraph{VSDX} The ''\textbf{vsdx}'' module is a dedicated module which provides an API and an implementation for the processing of Microsoft Visio 2013 VSDX documents. The module defines an abstraction layer describing the structure of a Visio document in an object-oriented fashion, and is used for the serialization and de-serialization of VSDX files.

\paragraph{SysML4Mechatronics} The ''\textbf{sysml4mechatronics}'' module contains a number of APIs and implementations for them, used for the serialization and de-serialization of SFB769 SysML4Mechatronics files.

\section{Components}
\label{sec:impl:components}

\color{red} TODO verbatimize class names \color{black}

After, in the last section, the coarse-level division of the PSS-IF PoC parts through Maven modules was presented, this section focuses on a more detailed overview of the fine-level architectural components of the tool. Each of the following subsections describes the function and structure of a specific component of the transformation framework PoC.

\subsection{Core}

The core is the central component of the framework and is responsible for the realization of key concepts, used for the definition and processing of transformations. The core encloses two major concepts -- those of a Metamodel and a Model, which were already presented in \chapref{chap:approach}. \color{red}TODO figref\color{black} presents a UML Class Diagram of the core.

\subsubsection{Metamodel}

The Metamodel is a concept which enables the users of the framework to define the structure of their data. In this sense, a Metamodel also defines, on the abstract syntax level, the language in which the elements of a PSS-IF Model are described. A parallel in the domain of the Extensible Markup Language (XML) are the XML Schema Definitions (XSD). In essence, a PSS-IF Metamodel is the schema definition in accordance with which a particular Model is created and processed.

A PSS-IF Metamodel captures a number of concepts. In particular, it consists of Node and Edge Types, i.e. elements which enable the user to define what kinds of nodes and edges their model can have, what kinds of features they may have, and how they may relate to each other. Furthermore, in the PSS-IF PoC, inheritance relations can be defined between both Node and Edge types.

\paragraph{Node Types}

Node Types are used for the description of the different kinds of nodes in a model and have a number of features. All Node Types are named and the name must be unique in the scope of all Node and Edge Types within a Metamodel. Furthermore, Node Types can have a number of attributes, and are connected to other Node Types over Edge Types, which can be both incoming and outgoing.

There are two categories of Node Types -- conventional ones and Junction Node Types. The latter are actually Node Types with edge semantics, i.e. they are used for the representation of hyper-edges.

\paragraph{Edge Types}

Edge Types are used for the description of possible edges in a user's model. Edge Types also have a name, which is unique in the scope of a Metamodel. For it to be possible to associate the same Edge Type with different pairs of Node Types, the concept of Connection Mappings is used. A Connection Mapping is an association assigned to a particular Edge Type, which includes an incoming and an outgoing Note Type.

To illustrate the usage of the Connection Mappings, consider the following example: Assuming two Node Types, denoted ''State'' and ''Function'' and an Edge Type ''Control Flow'', which has to connect both Node Types in both directions. In the PSS-IF PoC this is achieved by defining a single Edge Type ''Control Flow'' and assigning two Connection Mappings to it: one from ''State'' to ''Function'' and one from ''Function'' to ''State''.

\paragraph{Attributes}

For both Node and Edge Types, Attributes can be defined. Attributes are divided into Attribugte Groups, which can be used to separate different kinds of attributes conveniently, for example in a user interface. Furthermore, Attributes are identified by their names, which have to be unique in the scope of the owning Node or Edge Type. Also, each attribute has a Data Type. The PSS-IF PoC defines a number of primitive data types, like String, Integer, Date and Boolean, and also provides the user with the ability to define custom enumeration data types. Finally, Attributes can optionally have a Unit associated with them, which can be particularly useful for numeric Attributes. Finally, Attributes are divided into categories. Currently, the following categories are defined: Monetary, Weight, Density, Time, Geometry, MetaData and Material.

\paragraph{Inheritance}

As already noted above, for both Node and Edge Types, inheritance relations can be defined. When a Node Type inherits from another Node Type, it holds that Attribute Groups and Attributes are inherited from the parent. With Edge Types, inheritance is slightly more complex. For Attributes, the same rule holds as for Node Types. Connection Mappings are generally not inherited. Nonetheless, when extracting the instances of a Node or Edge Type from a Model, the user can specify whether instances of the specializations of this Node or Edge Type should be included in the result set. \color{red}TODO more detail, better formulation \color{black}.

\paragraph{Built-In Metamodel Elements}

Every PSS-IF Metamodel has a number of predefined elements. These are the root Node and Edge Types. The root node type has the name ''Node'' and provides the following predefined Attributes:

\begin{itemize}
\item \textbf{id}: An identifier with data type String for the node instance of the node type, categorized as Metadata.
\item \textbf{name}: A name with data type String, categorized as Metadata.
\item \textbf{validity start}: A Date, designating the begin of the validity period of the given node, categorized as Time.
\item \textbf{validity end}: A Date, designating the end of the validity period of the given node, categorized as Time.
\item \textbf{version}: The version of the node, of data type String, categorized as Metadata.
\item \textbf{comment}: A comment of the node, of data type String, categorized as Metadata.
\end{itemize}

The root Edge Type ''Edge'' has all built-in Attributes defined for the root Node Type ''Node'', and also an additional Attribute \textbf{directed} of data type Boolean and categorized as Metadata. 

The root Node and Edge Types are also the roots of the inheritance hierarchies for Node and Edge Types within a Metamodel. In this sense, any Node or Edge Type automatically inherits from the root Node or Edge Type, accordingly. Thus, it is guaranteed that the set of Attributes provided above is automatically defined for all Node and Edge Types. If a Node or Edge Type inherits from a non-root Node or Edge Type, the Attributes are inherited transitively, together with all Attributes of all ancestors throughout the generalization closure.

\subsubsection{Model}

The second key component of the PSS-IF PoC core is the Model, which can be seen as a simple graph, consisting of Nodes and Edges. Nodes are ontological instances of the Node Types and Edges are ontological instances of the Edge Types of a PSS-IF Metamodel. Note that the elements of the Model are not type-aware themselves and can thus be accessed with different Metamodels.

In the PSS-IF PoC this strategy is used extensively, and Models do not provide any information or allow any operations themselves. All access points to a Model have to be navigated through a Metamodel, i.e. a Metamodel \textit{operates} on a Model. This makes it possible to switch between Metamodels as the user sees fit, but also to ensure data integrity at all times, by enforcing all modifications to be applied through the Metamodel, which plays the role of the schema for the data contained in the model.

\subsection{Transformations}

After the core, the next most important component of the PSS-IF PoC is the transformation API. As already noted in \chapref{chap:approach}, the authors have adopted the ISO 42010 approach, which defines different stakeholders as having different views on their data. Since the utility defines structures on the meta-level, the PoC describes the views of different stakeholders (source and destination languages) through corresponding Metamodels, called Viewpoints. These are mutable Metamodels, which can be \textit{transformed}. For this purpose, Viewpoints accept a \texttt{Transformation}, which is a function mapping a Metamodel to a Metamodel.

Thus, the application of a \texttt{Transformation} results in a \texttt{Viewpoint}, i.e. a Metamodel, which modifies the behaviour of the input Metamodel in accordance with the particular kind of transformation used. As a result, transformations can be applied consequently, each one operating on the result of the previous. This process is illustrated in \color{red} TODO seq. diag. of 2+ transformations, with calls to viewpoints?\color{black}.

Since the behaviour of the \texttt{Viewpoint} is independent of the particular kind of transformation used, the definition of a \texttt{Viewpoint} is reduced to the definition of all necessary transformations and their combination in the appropriate order. The current set of available transformation covers all the ones described in \chapref{chap:approach}.

\subsection{Generic Graph}

A simple component used for intermediate steps in the transformation process is the generic graph component of the PSS-IF PoC. This component is a simple undirected graph consisting of nodes and edges, which can have string-named attributes with string values, as well as the name of their assumed type (see \color{red}TODO fig UML Class of simple graph\color{black}). In this sense, the graph is an untyped and unstructured equivalent of a PSS-IF Model.

In the transformation process, the generic graph is used as an intermediate format, separating the concrete syntax and the abstract syntax of each supported language. The concrete syntax is defined by the file provided by the user and is handled by an \texttt{IoMapper} (see \secref{sec:impl:comp:io}), which the abstract syntax is defined by the \texttt{Viewpoint} and is processed by a \texttt{ModelMapper} (see \secref{sec:impl:comp:model}). The details of the process are provided in \secref{sec:impl:process}.

\subsection{I/O Mappers}
\label{sec:impl:comp:io}

The I/O Mapper component is responsible for the serialization and de-serialization of a generic graph to and from a stream. In this sense, the component has the task to abstract over the concrete syntax used for the representation of the user's data in any particular language. The API of the component is the \texttt{IoMapper} interface, which has the following signature:

\begin{itemize}
\item \texttt{Graph read(InputStream in);}
\item \texttt{void write(Graph graph, OutputStream out);}
\end{itemize}

Note that the same \texttt{IoMapper} may be used for more than one language. For example, the \texttt{VsdxIoMapper} could be used for both EPC and BPMN.

\subsection{Model Mappers}
\label{sec:impl:comp:model}

The Model Mapper component is responsible for the translation between generic graphs and PSS-IF Models under the provision of a corresponding PSS-IF \texttt{Viewpoint} (Metamodel). In this sense, it handles the translation between the abstract syntax of the external representation and the abstract syntax of the language's viewpoint in PSS-IF. The component is realized through the \texttt{ModelMapper} interface, which has the following signature:

\begin{itemize}
\item \texttt{Model read(Metamodel metamodel, Graph graph);}
\item \texttt{Graph write(Metamodel metamodel, Model model);}
\end{itemize}

In the simplest case, a particular model mapper would simply use the provided viewpoint to directly transfer information between a Model and a graph, processing all nodes, edges and attributes. In more complex cases, pre- or post-processing of the graph may be necessary, so that is ''normalized'' to a structure compatible with the viewpoint defined for the particular language (and, hence, with the provided Model). This may, for example, be the case, if the external representation requires the nodes of a graph to be ordered in accordance with a certain rule, or if there are implicit existential dependencies between nodes, implied by the nature of the \texttt{Viewpoint} or a specific \texttt{Transformation}.

In general, it is assumed that one \texttt{ModelMapper} implementation is necessary for each format to support. Theoretically, if the same language is to be imported from or exported to more than one format, and the generic graph is sufficient to express the abstract syntax of both external formats, the same \texttt{ModelMapper} and \texttt{Viewpoint} can be used with different \texttt{IoMapper} implementations, to obtain different serializations of the same data.

\subsection{Microsoft Visio VSDX I/O}

For the serialization and de-serialization of Microsoft Visio 2013 VSDX files needed to support EPC and BPMN, a special component was developed in a dedicated Maven module. The component defines an API for the manipulation of VSDX files, operating with the following abstractions:

\begin{itemize}
\item \texttt{VsdxDocument} An object-oriented representation of an entire VSDX document.
\item \texttt{VsdxPage} A page within a VSDX document.
\item \texttt{VsdxMaster} A master shape defined within a VSDX document.
\item \texttt{VsdxShape} A shape, contained either in a page, or in another shape.
\item \texttt{VsdxConnector} A connector shape, i.e. a shape which connects two other shapes.
\end{itemize}

The interrelation of the different concepts of the VSDX API are depicted in \color{red} TODO UML Class Diagram of Visio interfaces\color{black}.

It should be noted that the current VSDX component does not provide any mechanisms for layouting, colouring, or other finer operations on a Visio file. This is because the component is aimed explicitly at the extraction and generation of data. The layout of Visio files exported from PSS-IF can be fixed through the usage of algorithms which are built-in in Microsoft Visio. If special decoration of shapes is required, the user's can provide their own template files with correspondingly modified master shapes. These template files can then be used in combination with the VSDX component to produce appropriately formatted Visio files. Finally, the API can be extended in future works, to support fines layouting and formatting operations.

\section{Mapping Process}
\label{sec:impl:process}

After, in the last section, the different components of the PSS-IF PoC were presented, this section focuses on how the components hang together and describes the mapping (import and export) process in detail. Here, the term mapping is used, as it covers the processes in both directions and the PSS-IF PoC implementation handles both cases in the same fashion.

\paragraph{API} The mapping processes are triggered over the corresponding API, represented by the \texttt{Mapper} interface, which has the following signature:

\begin{itemize}
\item \texttt{Model read(Metamodel metamodel, InputStream inputStream);}
\item \texttt{void write(Metamodel metamodel, Model model,}\\ \texttt{OutputStream outputStream);}
\end{itemize}

\paragraph{Implementation} While each specific language, for each file format, requires its own \texttt{Mapper} implementation, the internal procedure for all languages and file formats is the same and is described by the \texttt{AbstractMapper} class, which is the super-class of all \texttt{Mapper} implementations. The \texttt{AbstractMapper} defines the methods of the \texttt{Mapper} API as follows:

\begin{verbatim}
public abstract class AbstractMapper implements Mapper {

 @Override
  public final Model read(Metamodel mm, InputStream in) {
    Graph graph = getIoMapper().read(in);
    Metamodel view = getView(mm);
    ModelMapper modelMapper = getModelMapper();
    return modelMapper.read(view, graph);
  }

  @Override
  public final void write(Metamodel mm, Model m, OutputStream out) {
    Metamodel view = getView(mm);
    ModelMapper modelMapper = getModelMapper();
    Graph graph = modelMapper.write(view, m);
    getIoMapper().write(graph, out);
  }

  protected abstract Metamodel getView(Metamodel metamodel);

  protected abstract ModelMapper getModelMapper();

  protected abstract IoMapper getIoMapper();
 }
\end{verbatim}

As the code snippet demonstrates, a PSS-IF \texttt{Model} instance is obtained from an external representation by transcoding the external representation into a generic graph, obtaining the \texttt{Viewpoint} of the current language and finally mapping the generic graph to a model in accordance with the viewpoint.

Symmetrically, a file is generated from a PSS-IF \texttt{Model} by first obtaining the \texttt{Viewpoint} for the current language and using it to translate the model into a generic graph, and then serializing the graph to a stream through the corresponding \texttt{IoMapper}.

\paragraph{Process}

Recall the 6-step process described in \secref{sec:approach:pssif:nutshell}, which describes the transformation process on the conceptual level. In the PSS-IF PoC, the transformation process is implemented through the consequent invocation of two mappers. The first one is the mapper which de-serializes the source data and transforms it into a Model conforming to the PSS-IF Canonic Metamodel. The second mapper is the one for the target format and is used to write the obtained model into an external representation. For an exemplary source language A and target language B, the Java code describing the transformation process is the following:

\begin{verbatim}
public void transform(Mapper aMapper, Mapper bMapper,
  InputStream inputStream, OutputStream outputStream) {
  
  Metamodel metamodel = PSSIFCanonicMetamodelCreator.create();
  Model model = aMapper.read(metamodel, inputStream);
  bMapper.write(metamodel, model, outputStream);
}
\end{verbatim}

\color{red}TODO picutre of the process?\color{black}



























